'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rawDifference = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let rawDifference = exports.rawDifference = (() => {
  var _ref = _asyncToGenerator(function* (options) {
    const actualFilename = options.actualFilename,
          expectedFilename = options.expectedFilename,
          diffFilename = options.diffFilename,
          other = _objectWithoutProperties(options, ['actualFilename', 'expectedFilename', 'diffFilename']);

    yield Promise.all([actualFilename, expectedFilename].map(function (filename) {
      return new Promise(function (accept, reject) {
        _fs2.default.exists(filename, function (actualExists) {
          if (actualExists) {
            accept();
            return;
          }

          reject(new Error(`\`image-difference\` expected "${filename}" filename to exist but it didn't`));
        });
      });
    }));

    const sizes = yield Promise.all([getImageSize(actualFilename), getImageSize(expectedFilename)]);

    // Find the maximum dimensions
    const actualSize = sizes[0];
    const expectedSize = sizes[1];
    const maxWidth = Math.max(actualSize.width, expectedSize.width);
    const maxHeight = Math.max(actualSize.height, expectedSize.height);

    let actualTmpFilename;
    let expectedTmpFilename;

    if (actualSize.width !== maxWidth || actualSize.height !== maxHeight) {
      actualTmpFilename = yield resizeImage(actualFilename, {
        width: maxWidth,
        height: maxHeight
      });
    }

    if (expectedSize.width !== maxWidth || expectedSize.height !== maxHeight) {
      expectedTmpFilename = yield resizeImage(expectedFilename, {
        width: maxWidth,
        height: maxHeight
      });
    }

    if (diffFilename) {
      yield new Promise(function (accept, reject) {
        (0, _mkdirp2.default)(_path2.default.dirname(diffFilename), function (err) {
          if (err) {
            reject(err);
            return;
          }

          accept();
        });
      });
    }

    const raw = yield createDifference(_extends({
      actualFilename: actualTmpFilename || actualFilename,
      expectedFilename: expectedTmpFilename || expectedFilename,
      diffFilename
    }, other));

    // Clean up the temporary files
    yield Promise.all([actualTmpFilename, expectedTmpFilename].filter(function (filename) {
      return filename;
    }).map(function (filename) {
      return new Promise(function (accept, reject) {
        _fs2.default.unlink(filename, function (err) {
          if (err) {
            reject(err);
            return;
          }

          accept();
        });
      });
    }));

    return {
      raw,
      width: maxWidth,
      height: maxHeight
    };
  });

  return function rawDifference(_x) {
    return _ref.apply(this, arguments);
  };
})();

exports.handleRaw = handleRaw;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _gm = require('gm');

var _gm2 = _interopRequireDefault(_gm);

var _crossSpawn = require('cross-spawn');

var _crossSpawn2 = _interopRequireDefault(_crossSpawn);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _tmp = require('tmp');

var _tmp2 = _interopRequireDefault(_tmp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const gmMagick = _gm2.default.subClass({ imageMagick: true });

function transparent(filename, options) {
  if (!options.width || !options.height) {
    throw new Error('Wrong options provided to transparent()');
  }

  const gmImage = gmMagick(filename);
  gmImage.background('transparent'); // Fill in new space with white background
  gmImage.gravity('NorthWest'); // Anchor image to upper-left
  gmImage.extent(options.width, options.height); // Specify new image size

  return gmImage;
}

function getImageSize(filename) {
  return new Promise((accept, reject) => {
    _fs2.default.stat(filename, err => {
      if (err) {
        reject(err);
        return;
      }
      gmMagick(filename).size((err2, value) => {
        if (err2) {
          reject(err2);
          return;
        }
        accept(value);
      });
    });
  });
}

function handleRaw(difference, options) {
  const raw = difference.raw,
        other = _objectWithoutProperties(difference, ['raw']);

  // Only process once


  if (typeof raw === 'number') {
    return difference;
  }

  let resultInfo;

  switch (options.metric) {
    case 'PAE':
    case 'MSE':
    case 'RMSE':
    case 'MAE':
      // Find variant between 'all: 0 (0)', 'all: 40131.8 (0.612372)', or 'all: 0.460961 (7.03381e-06)'
      // According to http://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=17284
      // These values are the total root mean square (MSE) pixel difference
      // across all pixels and its percentage
      resultInfo = raw.match(/all: (\d+(?:\.\d+)?(?:[Ee]-?\d+)?) \((\d+(?:\.\d+)?(?:[Ee]-?\d+)?)\)/);
      if (!resultInfo) {
        throw new Error(`Expected raw to contain 'all' but received "${raw}"`);
      }

      return _extends({}, other, {
        value1: parseFloat(resultInfo[1], 10),
        value2: parseFloat(resultInfo[2], 10)
      });

    case 'PHASH':
    case 'PSNR':
    case 'AE':
    case 'NCC':
    case 'FUZZ':
      resultInfo = raw.match(/all: (\d+(\.\d+)?)/);
      if (!resultInfo) {
        throw new Error(`Expected raw to contain 'all' but received "${raw}"`);
      }
      return _extends({}, other, {
        value: parseFloat(resultInfo[1], 10)
      });

    default:
      throw new Error('Unknown metric');
  }
}

function resizeImage(filename, options) {
  if (!options.width || !options.height) {
    throw new Error('Wrong options provided to resizeImage()');
  }

  return new Promise((accept, reject) => {
    // Get a temporary filepath
    _tmp2.default.tmpName({ postfix: '.png' }, (err, tmpFilename) => {
      // If there was an error, callback
      if (err) {
        reject(err);
        return;
      }

      transparent(filename, {
        width: options.width,
        height: options.height
      }).write(tmpFilename, err2 => {
        if (err2) {
          reject(err2);
          return;
        }

        accept(tmpFilename);
      });
    });
  });
}

function createDifference(options) {
  const actualFilename = options.actualFilename,
        expectedFilename = options.expectedFilename,
        diffFilename = options.diffFilename,
        implementation = options.implementation,
        metric = options.metric,
        highlightColor = options.highlightColor,
        lowlightColor = options.lowlightColor,
        fuzz = options.fuzz;


  const diffArgs = ['-verbose', '-highlight-color', highlightColor, '-lowlight-color', lowlightColor,
  // http://legacy.imagemagick.org/script/command-line-options.php#metric
  // http://www.imagemagick.org/Usage/compare/
  // https://github.com/ImageMagick/ImageMagick/blob/master/MagickCore/compare.c
  '-metric', metric].concat(fuzz ? ['-fuzz', fuzz] : [])
  // Paths to actual, expected, and diff images
  .concat([actualFilename, expectedFilename,
  // If there is no output image, then output to `stdout` (which is ignored)
  diffFilename || '-']);

  return new Promise((accept, reject) => {
    switch (implementation) {
      case 'imagemagick1':
        {
          // http://www.imagemagick.org/script/compare.php
          const proc = (0, _crossSpawn2.default)('compare', diffArgs);
          let stdout = '';
          let stderr = '';
          proc.stdout.on('data', data => {
            stdout += data;
          });
          proc.stderr.on('data', data => {
            stderr += data;
          });
          proc.on('close', code => {
            const isImageMagick = true;
            // ImageMagick returns err code 2 if err, 0 if similar, 1 if dissimilar
            if (isImageMagick) {
              if (code === 0 || code === 1) {
                stdout = stderr;
              } else {
                reject(stderr);
                return;
              }
            } else if (code !== 0) {
              reject(stderr);
              return;
            }
            accept(stdout);
          });
          break;
        }

      case 'imagemagick2':
        // http://www.imagemagick.org/script/compare.php
        // https://github.com/aheckmann/gm/blob/master/lib/compare.js
        gmMagick().compare(actualFilename, expectedFilename, {
          file: diffFilename
        }, (err, Boolean, equality) => {
          if (err) {
            reject(err);
            return;
          }

          accept(equality);
        });
        break;

      case 'graphicsmagick':
        {
          // http://www.graphicsmagick.org/GraphicsMagick.html
          // https://github.com/aheckmann/gm/blob/master/lib/compare.js
          _gm2.default.compare(actualFilename, expectedFilename, {
            highlightColor: 'RED',
            highlightStyle: 'Assign',
            file: diffFilename
          }, (err, Boolean, equality) => {
            if (err) {
              reject(err);
              return;
            }

            accept(equality);
          });
          break;
        }

      default:
        throw new Error('Unknow implementation');
    }
  });
}

exports.default = (() => {
  var _ref2 = _asyncToGenerator(function* (optionsWithoutDefault) {
    const actualFilename = optionsWithoutDefault.actualFilename,
          expectedFilename = optionsWithoutDefault.expectedFilename;
    var _optionsWithoutDefaul = optionsWithoutDefault.implementation;
    const implementation = _optionsWithoutDefaul === undefined ? 'imagemagick1' : _optionsWithoutDefaul;
    var _optionsWithoutDefaul2 = optionsWithoutDefault.metric;
    const metric = _optionsWithoutDefaul2 === undefined ? 'AE' : _optionsWithoutDefaul2;
    var _optionsWithoutDefaul3 = optionsWithoutDefault.highlightColor;
    const highlightColor = _optionsWithoutDefaul3 === undefined ? 'red' : _optionsWithoutDefaul3;
    var _optionsWithoutDefaul4 = optionsWithoutDefault.lowlightColor;
    const lowlightColor = _optionsWithoutDefaul4 === undefined ? 'white' : _optionsWithoutDefaul4;
    var _optionsWithoutDefaul5 = optionsWithoutDefault.fuzz;

    const fuzz = _optionsWithoutDefaul5 === undefined ? 0 : _optionsWithoutDefaul5,
          other = _objectWithoutProperties(optionsWithoutDefault, ['actualFilename', 'expectedFilename', 'implementation', 'metric', 'highlightColor', 'lowlightColor', 'fuzz']);

    // Assert our options are passed in


    if (!actualFilename) {
      throw new Error('`options.actualFilename` was not passed to `image-difference`');
    }

    if (!expectedFilename) {
      throw new Error('`options.expectedFilename` was not passed to `image-difference`');
    }

    const options = _extends({
      actualFilename,
      expectedFilename,
      implementation,
      metric,
      highlightColor,
      lowlightColor,
      fuzz
    }, other);

    const difference = yield rawDifference(options);
    return handleRaw(difference, options);
  });

  function imageDifference(_x2) {
    return _ref2.apply(this, arguments);
  }

  return imageDifference;
})();